## 아이템 1

### 생성자 대신 정적 팩터리 메서드를 고려하라

1. 클래스의 인스턴스를 얻는 정통적인 수단은 public 생성자. But, 클래스는 별도로 정적 팩터리 메서드를 제공할 수 있음.
2. 장점
    1. 이름을 가질 수 있다.
        1. 객체가 가지는 특성을 쉽게 묘사할 수 있다.
        ex.) BigInteger(int, int, Random), BigInteger.probabalePrime
        2. 시그니처가 같은 생성자를 여러 개 만드는데 제약이 없다.
        생성자를 정적 팩터리 메소드로 변경 후 각 차이를 잘 드러내도록 명명해주면 된다.
    2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        1. 불필요한 객체 생성을 피할 수 있다.
        Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다. ⇒ 성능을 끌어올려 준다.
    3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 
    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        1. 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
    5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
        1. 이런 유연함은 프레임워크를 만드는 근간이 된다. ex.) 대표적인 에로 JDBC가 있다.
3. 단점
    1. 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        1. 상속을 하려면 public or protected 생성자가 필요하기 때문에.
    2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

## 아이템 26

### 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 파라미터가 쓰이면, 제네릭 클래스 or 제네릭 인터페이스라 한다.

제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입 이라 한다.

1. ex.) List<String> 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다. 
2. 제네릭 타입을 하나 정의하면 그에 딸린 로(raw) 타입도 함께 정의된다.
제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. ex.) List<E> 의 로 타입은 List.
3. 컴파일러에 명확히 전달한 것에서 List와 List<Object>는 완전히 다르다.
    1. ex.) 매개변수로 List를 받는 메서드
    List<String>은 넘길 수 있음. But, List<Object>는 넘길 수 없음.
    제네릭의 하위 타입 규칙 때문. 
    즉 List<String>은 Law type List의 하위 타입 / List<Object>의 하위타입은 아님. 
4. 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안됨.
5. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐.